# 线程库思路

学习上届技巧，以学习以 fork 的思路进行多线程处理。fork 的开销比较巨大，所以我们学习并选择共享虚拟页表和栈。

在做并行处理的同学应当设计一些是否可以被 spill 的标识用于保证进程间不会因为共享同一个函数栈而产生竞争。这里建议，认为继承的栈中，共享部分作为只读资源，不共享的栈部分，比如数组的不同范围相关寄存器是可以 spill 的。但是一些共享的变量不可以 spill，否则会竞争。

## small thread library

学习上届比赛的北大队伍设计实现了简易的 STL（small thread lib）库。

该库仅支持非常简陋的线程并行，以减少调用时候的开销。使用的办法是创建 LWP 轻量级进程，其因为需要调用内核工作，所以创建时候有一定的开销，不可认为无开销而再循环中创建 100 个乃至 1k 个。这回使得瓶颈从运算转到内核空间的进程创建。

由于本质是 LWP 轻量级进程，一下皆以进程称呼。

``` c
/**
 * 相较于 fork，该 fork 只使用了 SIGCHLD 和 CLONE_VM 选项。原因是 sysy 程序实际上只关注运算问题，
 * 而对于 IO 上的问题是不需要考虑的，所以文件系统等内容统统不需要共享。
 * 可利用 Linux 内核的写时复制能力，减少开销。（目前无法度量）
 * 
 * 返回值：
 *  如果是主动调用 fork 的进程，返回产生的新进程的 id，不为 0
 *  如果是被创建的进程，则返回 0
 * 
 * 该返回值和 fork 一致
 * 
 * 子进程与父进程共享栈和虚拟地址空间，所以要注意使用的时候要标注相关变量是否一定要是寄存器类型以减少
 * 同步与互斥问题，锁的开销是巨大的，应当在有意义的位置使用
 */
int __crvc_fork();

/**
 * 该 waitid 仅用于等待一个子进程结束，需要被配置以等待所有的子进程结束
 * 
 */
int __crvc_waitid();

/**
 * 该 exit 用于退出当前进程
 * 
 */
int __crvc_exit();

/**
 * 该调用用于给自旋锁上锁，该锁目前是本地隐藏的，只有一个锁。
 * 
 */
int __crvc_spinlock_lock();

/**
 * 该调用用于给自旋锁解锁
 * 
 */
int __crvc_spinlock_unlock();
```

## 推荐的使用思路

将循环分割成 4 个部分（更多部分也可，一下以 4 举例），请谨慎分割成四份，不要遗漏。

源程序：

``` c
_sysy_starttime(__LINE__);
for (int i = 0; i < 4000000; ++i) {
    arr[i] = arr[i] / 2;
}
_sysy_stoptime(__LINE__);
```

改进后的程序：

``` c
_sysy_starttime(__LINE__);
for (int i = 0; i < 4; ++i) {
  int x = __crvc_fork();
  if (x == 0) {
    for (int j = 0; j < 1000000; ++j) {
      arr[i * 1000000 + j] = arr[i * 1000000 + j] / 2;
    }
    __crvc_exit();
  }
}
for (int i = 0; i < 4; ++i) {
  __crvc_waitid();
}
_sysy_stoptime(__LINE__);
```

将循环分为四个，并在外围包一层新的进程创建层：

``` c
for (int i = 0; i < 4; ++i) {
  int x = __crvc_fork();
  if (x == 0) {
    {
      // small task
    }
    __crvc_exit();
  }
}
for (int i = 0; i < 4; ++i) {
  __crvc_waitid();
}
```

以上代码就是用于分治的模板，将相互之间没有联系的循环分为 4 分后，塞到最里面的运行。

首先是主进程的四次进程创建，每次外层循环，主进程都会分裂出一个子进程来计算内容，该模板不选择将主进程纳入运算中。主进程因为返回值为非 0 而不会进入条件判断，自然而然的进入下一轮创建。

而子进程因为返回值 x 为 0，所以会进入条件中，并在条件位的 exit 里退出。

最后主进程离开创建循环并进入 waitid 等待一个子进程结束，需要对每个子进程都进行等待以保证所有运算任务都结束。

注意，这阶段需要标注几个变量为一定为保存在寄存器里：

1. 创建循环里的 x 变量和 i 变量
2. 最内存循环里，涉及到同步与互斥的变量，比如第二个程序片段里的 j 变量，不能被挤到栈上

该要求目前是因为进程创建的时候没有给每个进程独立的栈空间，而是和主进程共享。这个其实可以做到自己独立开辟栈区，目前还未设计，可能会在未来添加。

目前的思路：

前端预估会需要多大的栈，并使用 alloca 分配，给出 hint。后端按照这些信息安排栈结构。每次调用 fork 的时候都会让主进程开辟一段栈空间。注意总共开辟的空间不过大，不然会产生栈溢出问题。