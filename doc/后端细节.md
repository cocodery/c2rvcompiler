
# 后端细节说明

使用了不少自定义的数据结构，可能问题多多，在考虑修改的时候要纳入考虑。

## Saving 状态

当经过一个函数调用的时候，需要被 caller 保存的寄存器会被保存到栈上。当函数返回后，这些寄存器的值并不会马上被使用，而可能会直接开始下一次函数调用。那么此时这些寄存器是不需要被恢复的，故使用一个 Saving 位指示当前寄存器已经保存在栈上可以不用做取出再加载的操作。

## Interval Manager

活跃区间，使用二进制位表示是否在某个位置活跃。目前用该方法判断是否会产生冲突。

该方法虽然想法非常好，但可能会造成非常大的存储浪费。

## 栈组织

```
+-------------------+ <--- fp
| ra                |
+-------------------+
| s0/fp             |
+-------------------+
| callee/caller     |
| save registers    |
+-------------------+
| remain spills     |
+-------------------+
| alloca for now    |
| short type first  |
| then long array   |
+-------------------+
| spills until      |
| (addr - sp) < 2048|
+-------------------+
| arguments > 8     |
+-------------------+ <--- sp
```

## 寄存器偏好

当函数内不调用其他函数的时候，优先使用 t 和 a 寄存器。

当函数内调用其他函数的时候，优先使用 s 寄存器。

## 基于局部的 split 想法

目前的活跃区间管理类是基于基本块记录信息的。同时，已经分离出了单独基本块的权重计算。

当权重计算更加成熟以后，比如将循环分析完成后，就可以以基本块为单位进行寄存器抢占。该抢占依然是基于权重计算。